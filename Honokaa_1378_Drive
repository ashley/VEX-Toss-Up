#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  lift,           sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  drive,          sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           liftLin,       tmotorVex393, openLoop)
#pragma config(Motor,  port2,           driveLMid,     tmotorVex393, openLoop)
#pragma config(Motor,  port3,           driveLBack,    tmotorVex393, openLoop, encoder, encoderPort, I2C_2, 1000)
#pragma config(Motor,  port4,           liftL,         tmotorVex393, openLoop)
#pragma config(Motor,  port5,           intakeL,       tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port6,           intakeR,       tmotorVex393, openLoop)
#pragma config(Motor,  port7,           liftR,         tmotorVex393, openLoop, reversed, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,  port8,           liftRin,       tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port9,           driveRMid,     tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port10,          driveRBack,    tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int armHeight = 0;

task ArmControl()
{
int error = 0;
int speed = 0;
float integral = 0;
float derivative = 0;
int previousError = 0;
int encoderValue = 0;

const int ACCEPTABLE_ERROR = 0;
const int INTEGRAL_UPPER_BOUND = 100;

int P_VALUE = 0; //For debugging.  Calculates constant*value to view amount of motor adjustment for each of the 3 parts.
int I_VALUE = 0;
int D_VALUE = 0;

float KP = 2.5; //0.4
float KI = 0;
float KD = 0;

SensorValue(lift) = 0;
while (1) //Loop continously to make sure task doesn't stop
{
//-------find the error-----------------------------
encoderValue = SensorValue(lift);
error = armHeight - encoderValue;  //Remember, error can be + or -
if( abs(error) < ACCEPTABLE_ERROR )
{
error = 0;
}
//--------get the integral--------------------------
integral = integral + error;
if ( error == 0 )
{
integral = 0;
}
if ( integral * KI > INTEGRAL_UPPER_BOUND)
{
integral = 0;
}


//---------get derivitive and previous error--------
derivative = error - previousError;
previousError = error;

//---------Factor in the constants (for debugging)--
P_VALUE = KP * error;
I_VALUE = KI * integral;
D_VALUE = KD * derivative;

//---------set speed using PID and K constants------
speed = P_VALUE + I_VALUE + D_VALUE;

//---------motor control goes here------------------
if( vexRT( Btn6U ) )
{
motor[liftL] = 127;
motor[liftR] = 127;
motor[liftLin] = 127;
motor[liftRin] = 127;

ArmHeight = SensorValue(lift) + 8;
}
else if( vexRT( Btn6D ) )
{
motor[liftL] = -127;
motor[liftLin] = -127;
motor[liftR] = -127;
motor[liftRin] = -127;

ArmHeight = SensorValue(lift);
}
else //4if ( !(SensorValue(liftEncoder) < 10 ) && !(armHeight < 10 ) )
{
motor[liftL] = speed;
motor[liftLin] = speed;
motor[liftR] = speed;
motor[liftRin] = speed;
}
//wait1Msec(5);
}
}


task main()
{
armHeight = 0;
StartTask(ArmControl);
while( true )
{
wait1Msec(25);

motor[driveLMid] = vexRT[Ch3];
motor[driveLBack] = vexRT[Ch3];


motor[driveRMid] = vexRT[Ch2];
motor[driveRBack] = vexRT[Ch2];

if( vexRT( Btn6U ) )
{
motor[liftL] = 127;
motor[liftLin] = 127;
motor[liftR] = 127;
motor[liftRin] = 127;
}
else if( vexRT( Btn6D ) )
{
motor[liftL] = -127;
motor[liftLin] = -127;
motor[liftR] = -127;
motor[liftRin] = -127;

}
else
{
motor[liftL] = 0;
motor[liftLin] = 0;
motor[liftR] = 0;
motor[liftRin] = 0;
}

if( vexRT( Btn5U ) )
{
motor[intakeL] = 127;
motor[intakeR] = 127;
}
else if( vexRT( Btn5D ) )
{
motor[intakeL] = -127;
motor[intakeR] = -127;
}
else
{
motor[intakeL] = 0;
motor[intakeR] = 0;
}
wait1Msec(5);
}
}
